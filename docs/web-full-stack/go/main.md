



## 泛型

Go 的泛型：https://juejin.cn/post/7183613424230727740#heading-8

泛型的引入提高了Go的编码效率，但 **编码效率**，**编译速度**，**运行速度** 三者是无法同时提高的。Go引入泛型后，会提高编码效率，但编译速度和运行速度会有略微降低。可以通过了解Go的泛型实现，从而了解为什么会降低编译速度和运行速度。

实现泛型的两种常见方式为 **“虚拟方法表”** 和 **“单态化”** 。

#### 虚拟方法表（Virtual Method Table）

泛型函数，在编译时都会被编译器改成只接受指针作为参数，因为指针都是一样的，所以可以只编译一份代码。这些指针的值都被分配到堆上，调用泛型函数时会将指针传递给泛型函数。

当传入的对象，且要调用对象的方法时，由于只有指向对象的指针，不知道方法在哪，所以需要一个查询方法的内存地址的表格 **“Virtual Method Table”** ，根据table查询到对应的方法地址。指针值的推导和调用虚拟函数，会比直接调用函数慢。

#### 单态化（Monomorphization）

编译器为每个被调用传入的数据类型，生成一个泛型函数的副本。对应的编译速度会慢，但运行时性能会更快，跟不使用泛型一致。

#### Go的实现

go采用了两者结合的实现。

- 对于值类型，比如int、int32、struct{} 等，会分别生成一份对应的代码副本。且int和type MyInt int，其底层类型都是int，只会生成同一个副本
- 对于指针类型和接口类型的调用，会统一生成一份泛型方法的副本。调用到方法时根据方法表动态查找方法地址

综上可以理解为什么Go泛型引入后，编译速度和运行速度都会略微下降了。

### 符号“~”

符号“~”，指底层类型约束，举个例子。

```go
type Slice[T int | int32] []T
type MyInt int
var a Slice[MyInt] // 错误
```

MyInt底层类型是int，但其本身并不是int，所以不能用于Slice[T int | int32]的实例化。

可以使用 ~int 的写法，表示所有以int为底层类型的类型都可以用于实例化。

```go
go

复制代码type Slice[T ~int | ~int32] []T
type MyInt int
var a Slice[MyInt] // 正确
```

## 使用

从Go 1.18后，空接口interface{}的定义发生了变更，它可以表示**所有类型的集合**。



